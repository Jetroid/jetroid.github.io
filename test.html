---
layout: default
donotlinkback: true
custom_style_includes:
- home
---
<script src="https://cdnjs.cloudflare.com/ajax/libs/parallax/3.1.0/parallax.min.js"></script>
<script src="/assets/js/brushstroke.min.js"></script>
<div class="hero-container-wrapper">
	<div id="hero-container" class="hero-container">
		<div id="scene" class="scene">
			<div data-depth="0.00"><img src="/assets/images/hero/far.png"></div>
			<div data-depth="0.08"><img src="/assets/images/hero/middle.png"></div>
			<div data-depth="0.11"><img src="/assets/images/hero/close.png"></div>
			<div data-depth="0.13"><img src="/assets/images/hero/stamp.png"></div>
			<div data-depth="0.15"><img src="/assets/images/hero/photo.png"></div>
			<div data-depth="0.15">
				<div class="header-wrapper">
					<div class="header-text">
						<a href="#projects">Projects</a>
						<a href="/blog/">Blog</a>
						<span id="mail"></span>
					</div>
				</div>
			</div>
			<div class="ghost" data-depth="0.40"><img src="/assets/images/hero/name.png" alt="Jet 'Jetroid' Holt"></div>
		</div>
	</div>
</div>
<div class="full-page">
</div>
<div class="full-page">
	<div class="title-wrapper">
		<h1>Example with a really really really long title</h1>
	</div>
	<div class="title-wrapper">
		<h2>Example with a really really really long title</h1>
	</div>
	<div class="title-wrapper">
		<h3>Example with a really really really long title</h1>
	</div>
	<div class="title-wrapper">
		<h4>Example with a really really really long title</h1>
	</div>
	<div class="title-wrapper">
		<h5>Example with a really really really long title</h1>
	</div>
	<div class="title-wrapper">
		<h6>Example with a really really really long title</h1>
	</div>
</div>
<div class="full-page">
	<div class="title-wrapper">
		<h1>Example with a <br/>title that goes on<br/> multiple lines</h1>
	</div>
	<div class="title-wrapper">
		<h2>Example with a <br/>title that goes on<br/> multiple lines</h1>
	</div>
	<div class="title-wrapper">
		<h3>Example with a <br/>title that goes on<br/> multiple lines</h1>
	</div>
	<div class="title-wrapper">
		<h4>Example with a <br/>title that goes on<br/> multiple lines</h1>
	</div>
	<div class="title-wrapper">
		<h5>Example with a <br/>title that goes on<br/> multiple lines</h1>
	</div>
	<div class="title-wrapper">
		<h6>Example with a <br/>title that goes on<br/> multiple lines</h1>
	</div>
</div>
<div class="full-page">
	<div class="title-wrapper">
		<h1>Short Title</h1>
	</div>
	<div class="title-wrapper">
		<h2>Short Title</h1>
	</div>
	<div class="title-wrapper">
		<h3>Short Title</h1>
	</div>
	<div class="title-wrapper">
		<h4>Short Title</h1>
	</div>
	<div class="title-wrapper">
		<h5>Short Title</h1>
	</div>
	<div class="title-wrapper">
		<h6>Short Title</h1>
	</div>
</div>
<div class="full-page">
</div>
<div class="full-page">
	<div class="title-wrapper">
		<h1>Solo Title</h1>
	</div>
</div>
<div class="full-page">
	<div class="title-wrapper">
		<h1>Solo Title</h1>
	</div>
</div>
<div class="full-page">
	<div class="title-wrapper">
		<h1>Solo Title</h1>
	</div>
</div>
<div class="full-page">
	<div class="title-wrapper">
		<h1>Solo Title</h1>
	</div>
</div>
<div class="full-page">
	<div class="title-wrapper">
		<h1>Solo Title</h1>
	</div>
</div>
<div class="full-page">
	<div class="title-wrapper">
		<h2>Solo Title</h1>
	</div>
</div>
<div class="full-page">
	<div class="title-wrapper">
		<h2>Solo Title</h1>
	</div>
</div>
<div class="full-page">
	<div class="title-wrapper">
		<h2>Solo Title</h1>
	</div>
</div>
<div class="full-page">
	<div class="title-wrapper">
		<h2>Solo Title</h1>
	</div>
</div>
<div class="full-page">
	<div class="title-wrapper">
		<h2>Solo Title</h1>
	</div>
</div>
<script>
/* Generate a random int between lower (inclusive) and upper (exclusive) */
var rint = function(lower, upper){
	return Math.floor(Math.random()*((upper-1)-lower+1)+lower);
};
var drawIndex = rint(0,3);
var drawBackground = function(wrapper) {
	var title = wrapper.firstElementChild;
	/* We provide some margin so that the paint can splash around */
	var marginX = 200;
	var marginY = title.offsetHeight;
	var mywidth = wrapper.offsetWidth + 2*marginX;
	var myheight = wrapper.offsetHeight + 2*marginY;

	var wrapperStyle = window.getComputedStyle(wrapper);

	var titleStyle = window.getComputedStyle(title);
	var fontSize = parseFloat(titleStyle.getPropertyValue("font-size"));
	var paddingX = parseFloat(titleStyle.getPropertyValue("padding-left")) +
						parseFloat(titleStyle.getPropertyValue("padding-right"));
	var paddingY = parseFloat(titleStyle.getPropertyValue("padding-top")) +
						parseFloat(titleStyle.getPropertyValue("padding-bottom"));
	var rawwidth = title.offsetWidth - paddingX;
	var rawheight = title.offsetHeight - paddingY;

	var padL = title.offsetLeft + marginX;
	var padR = mywidth - (title.offsetLeft + rawwidth) - marginX;
	var padT = title.offsetTop + marginY;

	var lineHeight = parseFloat(titleStyle.getPropertyValue("line-height"));

	var rawarea = rawwidth * rawheight;

	/* We want to go to the end of the last word on the last line */
	var titleTextChunks = title.innerHTML.split(" ");
	var last = titleTextChunks.pop();
	var rest = titleTextChunks.join(" ");
	var titleTextHTML = "<span>" + rest +"</span> <span>" + last + "</span>";
	title.innerHTML = titleTextHTML;
	var lastWord = title.lastElementChild;
	var lastX = lastWord.offsetLeft + lastWord.offsetWidth;



	/* Options for customization */
	var options = {
		width: mywidth,
		height: myheight,
		animation: "points",
		size: rawheight * 1.2 + 10,
		duration: 1,
		root: wrapper,
		color: "#94cbc4",
		queue: true,
		inkAmount: 6 + rawarea/20000,
		splashing: true
	};

	/* Initialization */
	var bs = new Brushstroke(options);
	var canvas = wrapper.lastElementChild;
	canvas.style.left = "-" + marginX + "px";
	canvas.style.top = "-" + marginY + "px";




	var drawingtype = drawIndex;
	drawIndex = (drawIndex + 1) % 3;

	if (drawingtype === 0) {
		/* This style swipes right then left then right again */
		bs.draw({
			points: [
				padL - 10 + rint(0,3), padT - 5 + rint(0,3),
				mywidth - padR - 5 + rint(0,3), padT + fontSize*0.5 + rint(0,3)
			],
			duration: 0.4,
			delay: 2
		});
		bs.draw({
			points: [
				mywidth - padR - 10 + rint(0,3), padT + fontSize + rint(0,3),
				padL + 5 + rint(0,3), padT - 5 + rawheight * 0.6 + rint(0,3)
			],
			size: rawheight * 1.2,
			duration: 0.2
		});

		bs.draw({
			points: [
				padL + 10 + rint(0,3), padT + rawheight * 0.6 + rint(0,3),
				lastX + padL - 10 + rint(0,3), padT + rawheight + rint(0,3) + lastX/900
			],
			duration: 0.3,
			dripping: true
		});
	} else if (drawingtype === 1) {
		/* This style draws a horizontal line for each line */
		var lines = Math.floor(title.offsetHeight / lineHeight);
		for (var i = 0; i < lines - 1; i++) {
			bs.draw({
				delay: 0.1,
				points: [
					padL - 15 + rint(0,10), padT + lineHeight * (i + 0.5) - 2 + rint(0,5),
					mywidth - padR + 15 - rint(0,10), padT + lineHeight * (i + 0.5) - 3 + rint(0,7)
				],
				size: lineHeight*2.5 + rint(0,6),
				duration: 0.2 + (rint(0,5)/10),
				inkAmount: 4 + rawarea / 15000
			});
		}
		/* The last line is shorter */
		bs.draw({
			delay: 0.1,
			points: [
				padL - 15 + rint(0,10), padT + rawheight - lineHeight/2 - 5 + rint(0,5),
				padL + lastX + 15 - rint(0,10), padT + rawheight - lineHeight/2 + 1 + rint(0,7)
			],
			size: lineHeight*2.5 + rint(0,6),
			duration: 0.2 + (rint(0,5)/10),
			inkAmount: 4
		});
	} else if (drawingtype === 2) {
		/* This style zigzags vertically */
		for (var i = padL - 20; i < (padL + rawwidth + 20); i+=50 ) {
			if (i > padL + lastX) {
				var offsetHeight = rawheight - lineHeight;
			} else {
				var offsetHeight = rawheight;
			}
			bs.draw({
				points: [
					i + rint(0,10), padT - 10 + rint(0,5),
					i + 25 - rint(0,10), padT + offsetHeight + 10 + rint(0,7)
				],
				size: 50 + rint(0,6),
				duration: 0.04,
				inkAmount: 4
			});
			bs.draw({
				points: [
					i + 25 + rint(0,10), padT + offsetHeight + 10 + rint(0,5),
					i + 50 - rint(0,10), padT - 10 + rint(0,7)
				],
				size: 50 + rint(0,6),
				duration: 0.04,
				inkAmount: 4
			});
		}
	}
	bs.promise = bs.promise.then(function(){console.log("Hello?");});

}
function onIntersection(entries) {
	for (var e in entries) {
		if(entries[e].intersectionRatio <= 0) continue;
		observer.unobserve(entries[e].target); 
		drawBackground(entries[e].target);
	}
}
document.addEventListener("DOMContentLoaded", (event) => {
    var wrappers = document.getElementsByClassName("title-wrapper");
	if ('IntersectionObserver' in window) {
		observer = new IntersectionObserver(onIntersection, {
			rootMargin: '250px'
		});
		for(var w in wrappers) {
			if(typeof wrappers[w] === 'object' && 'classList' in wrappers[w] &&
				 !wrappers[w].classList.contains('finished-animating')) {
				observer.observe(wrappers[w]);
			}
		}
	} else {
		for(var wrapper in wrappers) drawBackground(wrapper);
	}
});
</script>
<script>
var scene = document.getElementById('scene');

var parallaxInstance = new Parallax(scene, {
  invertX: false,
  invertY: false,
  hoverOnly: true
});


/* The higher this value, the less the fps will reflect temporary variations */
/* A value of 1 will only keep the last value */
var filterStrength = 20;
var frameTime = 0, lastLoop = new Date, thisLoop;

requestAnimationFrame(
    function loop(){
        var thisFrameTime = (thisLoop=new Date) - lastLoop;
		frameTime+= (thisFrameTime - frameTime) / filterStrength;
		lastLoop = thisLoop;
        requestAnimationFrame(loop);
    }
 );

/* Report the fps only every second, to only lightly affect measurements */
var fpsOut = document.getElementById('fps');
setTimeout(function() {
	setInterval(function(){
		var fps = 1000/frameTime;
		/*if(fps < 10) {
			parallaxInstance.destroy();
		}*/
	},1000);
}, 10000);

</script>
<script>ML="/@Ehmeif:jM.ol=\"<"+" tr>ac";MI="@EA3C57>?4E6=B<"+"835==<"+"195B3<"+"=B;F<"+"4?D24E6=A:5@0ED";OT="";for(j=0;j<MI.length;j++){OT+=ML.charAt(MI.charCodeAt(j)-48);}document.getElementById("mail").outerHTML=OT;</script>
